# opencode-teams Constitution

> Auto-generated by spec-kitty constitution command
> Created: 2026-02-09
> Version: 1.0.0

## Purpose

This constitution captures the technical standards, code quality expectations,
tribal knowledge, and governance rules for opencode-teams. All features and
pull requests should align with these principles.

opencode-teams is a thin wrapper around the OpenCode server, providing an
OpenCode plugin with custom tools for managing multi-agent teams. It mirrors
Claude Code's TeammateTool functionality with tmux integration. The immediate
goal is feature parity with Claude Code's team coordination; longer-term
extensions include beads integration, a beads viewer, workflow configuration,
and broader use of OpenCode plugin hook subscriptions for proactive event
processing by agents.

## Technical Standards

### Languages and Frameworks

- **TypeScript 5.3+** with `strict: true` (no exceptions)
- **Bun >= 1.3.2** as the primary runtime, package manager, and test runner
- **ES Modules** exclusively (`"type": "module"` in package.json)
- **Target**: ESNext with bundler module resolution
- **Peer dependency**: `@opencode-ai/plugin` (optional) for OpenCode integration
- **Runtime dependencies kept minimal**: yjs + y-websocket (CRDT/real-time), zod (validation)

### Bun-First Development

Follow this decision hierarchy when selecting APIs, packages, or tooling:

1. **Bun built-in API** - Always check first. Use `Bun.file()`, `Bun.write()`,
   `Bun.spawnSync()`, `Bun.serve()`, `bun test`, `bun x` before reaching for anything else.
2. **Bun-focused packages** - When Bun has no built-in, look for packages designed for
   or optimized for the Bun runtime before defaulting to Node.js ecosystem packages.
3. **Node.js / other fallback** - Only when neither a Bun-native API nor a Bun-focused
   package exists. Document the justification in a code comment.

Common substitutions:

- `Bun.file()` / `Bun.write()` over `fs.readFileSync` / `fs.writeFileSync`
- `Bun.spawnSync()` over `child_process.execSync`
- `globalThis.crypto` over `require('crypto')`
- `bun test` (backed by vitest) for testing
- `bun x tsc` for compilation

See `skills/quality-guards/SKILL.md` for the full Bun-first reference.

### Testing Requirements

- **Framework**: Vitest (v3.2+) via `bun test`
- **Pattern**: Descriptive nested `describe` blocks with `it` tests
- **Isolation**: Each test suite uses isolated temp directories; clean up in `afterAll`
- **Coverage**: All new features and operations must have corresponding unit tests. No specific numeric coverage target, but all public API surfaces and critical paths must be tested.
- **Integration**: Shell-based integration test (`tests/integration.sh`) for end-to-end verification

### Performance and Scale

Performance is not a primary concern at this stage, but:

- Use Bun's native APIs for I/O-bound operations (file reads, spawning processes)
- File-based storage in `.opencode/opencode-teams/` is the current persistence model
- Advisory file locking + atomic writes (write-to-temp-then-rename) ensure crash safety and cross-process concurrency
- Avoid unnecessary allocations in hot paths (task queue operations, message polling)

### Deployment and Constraints

- **Distribution**: npm package with public access and provenance signing
- **Platforms**: Cross-platform (Linux, macOS, Windows via Bun support)
- **Entry points**: ES module export (`dist/index.js`) + CLI binary (`dist/cli.js`)
- **Build output**: TypeScript compiler emits to `dist/` with declarations, declaration maps, and source maps
- **Lockfile**: `bun.lockb` committed for reproducible builds; CI uses `--frozen-lockfile`

## Code Quality

### Formatting and Linting

Enforced automatically via Lefthook pre-commit hooks (parallel execution):

- **Prettier**: Single quotes, ES5 trailing commas, 100-char line width, 2-space indent, semicolons required, arrow parens always
- **ESLint 9**: Flat config with `@typescript-eslint` and Prettier integration
  - `@typescript-eslint/no-explicit-any`: warn (avoid `any`, never suppress with `as any` or `@ts-ignore`)
  - `@typescript-eslint/no-unused-vars`: error (underscore prefix `_` allowed)
  - `no-console`: error (except `warn`, `error`, `log`)
- **ls-lint**: File and directory naming conventions (`.config/ls-lint.yml`)
  - Source files: `kebab-case` for `.ts`, `.js`, `.json`, `.yml`
  - Directories: `kebab-case`
  - Root markdown: `UPPERCASE` (e.g., `README.md`, `AGENTS.md`)
  - Catch-all `.*` wildcard enforces kebab-case on unknown extensions (root-file allowlist)
- **markdownlint-cli2**: Markdown standards (`.config/.markdownlint-cli2.jsonc`)
  - ATX headings, dash lists, 100-char lines, fenced code blocks
  - Scoped to `docs/`, `skills/`, `agent/`, `examples/`, root markdown files

### Config Directory Convention

CLI-only tool configurations that support `--config` flags live in `.config/`
to keep the project root clean. Configs required by IDE extensions (ESLint,
Prettier, TypeScript) remain in root. When adding a new tool, check if its
CLI supports a custom config path before placing the config in root.

### Pull Request Requirements

- PR title must follow [Conventional Commits](https://www.conventionalcommits.org/) format (enforced by `amannn/action-semantic-pull-request` GitHub Action)
- CI must pass: lint, test, build (GitHub Actions workflow on every PR)
- Types: `feat`, `fix`, `docs`, `style`, `refactor`, `test`, `chore`

### Quality Gates

All gates are automated and use a tiered strategy: commits stay fast and
progress-friendly; pushes and merges enforce strict compliance.

**Tier 1 - Pre-commit** (Lefthook, parallel, progress-friendly):

- `lint:fix` + `format` - auto-fix and re-stage (non-blocking)
- `typecheck` - type errors block commit (no `any` in production code)
- `ls-lint` - naming violations block commit (acts as root-file allowlist)
- `markdownlint` - warn only, branch-aware messaging:
  - On `main`/`master`: yellow warning, strongly recommends fixing before push
  - On feature branches: cyan info, advisory tone

**Tier 2 - Pre-push** (Lefthook, sequential, strict gate):

- `test` - full test suite must pass
- `build` - TypeScript compilation must succeed
- `ls-lint` - naming conventions re-checked
- `markdownlint` - markdown standards re-checked (blocking)

**Tier 3 - CI** (GitHub Actions):

- Setup, lint, test, build (all must pass)
- PR title: Semantic/conventional commit format

> See `skills/quality-guards/SKILL.md` for the full reference on all quality tools,
> naming conventions, config directory layout, and how to fix common violations.

### TypeScript Standards

- **Strict mode**: Always (`"strict": true` in tsconfig)
- **Naming**: PascalCase for types/interfaces, camelCase for functions/variables, UPPER_SNAKE_CASE for true constants
- **Explicit types**: Required for function parameters and return types
- **No type suppression**: Never use `as any`, `@ts-ignore`, or `@ts-expect-error`
- **Early returns**: Prefer over deep nesting
- **Error handling**: Always check error types (`error instanceof Error`) before accessing properties
- **Validation**: Use Zod schemas for all data crossing I/O boundaries (disk reads/writes, external input)

### Module Organization

- **Single responsibility**: One module per concern (team ops, task ops, tmux ops, file locking, atomic FS, storage paths)
- **Import order**: External libraries first, then internal modules
- **No `.ts` extensions** in import paths
- **Re-export from index**: Each directory has an `index.ts` barrel file
- **Plugin pattern**: Tools defined via OpenCode's `tool()` helper with Zod argument schemas

## Tribal Knowledge

### Architecture Decisions

- **File-based storage** over database: Chosen for simplicity, portability, and zero external dependencies. Teams, tasks, and inboxes are JSON files in `.opencode/opencode-teams/`.
- **Advisory file locking** (via Bun FFI): Provides cross-process safety without requiring a separate lock service. Not mandatory for correctness, but prevents data races.
- **Atomic writes** (write-temp-then-rename): Prevents corrupted files from partial writes or crashes.
- **Zod for runtime validation**: Every JSON file read from disk is validated through Zod schemas before use. This catches corruption and version mismatches early.
- **Thin wrapper philosophy**: This plugin should remain a lightweight coordination layer. Business logic belongs in the agents, not in the plugin. The plugin provides primitives (teams, tasks, messages); agents compose them.

### Team Conventions

- **Bun everywhere**: If Bun can do it, use Bun. Don't introduce Node.js patterns or dependencies without strong justification.
- **Minimal dependencies**: Every new dependency is a liability. Prefer built-in Bun/Node APIs or small focused libraries.
- **Keep the plugin lean**: Resist feature creep. If something can be an agent behavior instead of a plugin feature, make it an agent behavior.
- **Test in isolation**: Tests must not depend on global state. Use temp directories and clean up.
- **Conventional commits**: Every commit message must follow the format. release-please automates versioning and changelogs from these.
- **Clean root directory**: Do not leave scratch files, session dumps, or temp outputs in the project root. The ls-lint `.*` wildcard catches unexpected files. Delete stray files rather than adding them to ignore lists.
- **Configs in `.config/`**: Tool configs that support CLI `--config` flags belong in `.config/`, not the project root. Only configs required by IDE extensions stay in root.

### Lessons Learned

- Atomic file writes are non-negotiable for any file that multiple processes might touch simultaneously.
- Zod validation on disk reads catches subtle bugs where schema changes are made without migrating existing data files.
- Lefthook parallel pre-commit hooks significantly speed up the commit cycle; keep lint/format/typecheck independent so they can run concurrently.

### Roadmap Context

Current priorities in order:

1. **Claude Code parity**: Match TeammateTool feature set (team coordination, task queues, inter-agent messaging)
2. **Beads integration**: Connect with beads issue tracking for persistent cross-session work
3. **Beads viewer integration**: Visual interface for beads state
4. **Workflow configuration**: User-configurable workflow templates
5. **Plugin hook subscriptions**: Leverage OpenCode's event system for proactive agent processing (detecting conditions/events and dispatching agents automatically)

## Governance

### Amendment Process

Any team member can propose amendments via pull request. Changes are discussed
and merged following standard PR review process. The constitution should evolve
with the project; update it when conventions change rather than letting it drift.

### Compliance Validation

Code reviewers validate compliance during PR review. CI gates (lint, typecheck,
test, build) enforce the automated portions. Constitution violations should be
flagged and addressed before merge.

### Exception Handling

Exceptions discussed case-by-case with team. Strong justification required.
Consider updating the constitution if exceptions become common rather than
accumulating one-off waivers.
